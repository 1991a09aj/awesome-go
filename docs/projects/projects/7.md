+ [🔥 开源地址](https://github.com/cubxxw/iam)

# 第7节 高质量的Makefile

<br>

<div><a href = '6.md' style='float:left'>⬆️上一节🔗  </a><a href = '8.md' style='float: right'>  ⬇️下一节🔗</a></div>
<br>

> ❤️💕💕During the winter vacation, I followed up and learned two projects: tiktok project and IAM project, and summarized and practiced the CloudNative project and Go language. I learned a lot in the process.Myblog:[http://nsddd.top](http://nsddd.top/)

---
[[TOC]]

[TOC]

## 低质量的makefile

低质量的 Makefile 文件是什么样的;

```makefile

build: clean vet
  @mkdir -p ./Role
  @export GOOS=linux && go build -v .

vet:
  go vet ./...

fmt:
  go fmt ./...

clean:
  rm -rf dashboard
```

上面这个 Makefile 存在不少问题。例如：功能简单，只能完成最基本的编译、格式化等操作，像构建镜像、自动生成代码等一些高阶的功能都没有；扩展性差，没法编译出可在 Mac 下运行的二进制文件；没有 Help 功能，使用难度高；单 Makefile 文件，结构单一，不适合添加一些复杂的管理功能。

所以，我们不光要编写 Makefile，还要编写高质量的 Makefile。那么如何编写一个高质量的 Makefile 呢？我觉得，可以通过以下 4 个方法来实现：

+ 打好基础，也就是熟练掌握 Makefile 的语法。
+ 做好准备工作，也就是提前规划 Makefile 要实现的功能。
+ 进行规划，设计一个合理的 Makefile 结构。
+ 掌握方法，用好 Makefile 的编写技巧。



## 熟练makefile语法

**IAM 项目的 Makefile 文件：**

```bash

$ make help

Usage: make <TARGETS> <OPTIONS> ...

Targets:
  # 代码生成类命令
  gen                Generate all necessary files, such as error code files.

  # 格式化类命令
  format             Gofmt (reformat) package sources (exclude vendor dir if existed).

  # 静态代码检查
  lint               Check syntax and styling of go sources.

  # 测试类命令
  test               Run unit test.
  cover              Run unit test and get test coverage.

  # 构建类命令
  build              Build source code for host platform.
  build.multiarch    Build source code for multiple platforms. See option PLATFORMS.

  # Docker镜像打包类命令
  image              Build docker images for host arch.
  image.multiarch    Build docker images for multiple platforms. See option PLATFORMS.
  push               Build docker images for host arch and push images to registry.
  push.multiarch     Build docker images for multiple platforms and push images to registry.

  # 部署类命令
  deploy             Deploy updated components to development env.

  # 清理类命令
  clean              Remove all files that are created by building.

  # 其他命令，不同项目会有区别
  release            Release iam
  verify-copyright   Verify the boilerplate headers for all files.
  ca                 Generate CA files for all iam components.
  install            Install iam system with all its components.
  swagger            Generate swagger document.
  tools              install dependent tools.

  # 帮助命令
  help               Show this help info.

# 选项
Options:
  DEBUG        Whether to generate debug symbols. Default is 0.
  BINS         The binaries to build. Default is all of cmd.
               This option is available when using: make build/build.multiarch
               Example: make build BINS="iam-apiserver iam-authz-server"
  ...
```

通常而言，Go 项目的 Makefile 应该实现以下功能：格式化代码、静态代码检查、单元测试、代码构建、文件清理、帮助等等。如果通过 docker 部署，还需要有 docker 镜像打包功能。因为 Go 是跨平台的语言，所以构建和 docker 打包命令，还要能够支持不同的 CPU 架构和平台。为了能够更好地控制 Makefile 命令的行为，还需要支持 Options。

**为了方便查看 Makefile 集成了哪些功能，我们需要支持 help 命令。help 命令最好通过解析 Makefile 文件来输出集成的功能，例如：**

```bash
## help: Show this help info.
.PHONY: help
help: Makefile
  @echo -e "\nUsage: make <TARGETS> <OPTIONS> ...\n\nTargets:"
  @sed -n 's/^##//p' $< | column -t -s ':' | sed -e 's/^/ /'
  @echo "$$USAGE_OPTIONS"
```

上面的 help 命令，通过解析 Makefile 文件中的 `##` 注释，获取支持的命令。通过这种方式，我们以后新加命令时，就不用再对 help 命令进行修改了。



## 设计Makefile结构

对于大型项目来说，需要管理的内容很多，所有管理功能都集成在一个 Makefile 中，可能会导致 Makefile 很大，难以阅读和维护，所以建议采用分层的设计方法，**根目录下的 Makefile 聚合所有的 Makefile 命令，具体实现则按功能分类，放在另外的 Makefile 中。**

我们经常会在 Makefile 命令中集成 shell 脚本，但如果 shell 脚本过于复杂，也会导致 Makefile 内容过多，难以阅读和维护。并且在 Makefile 中集成复杂的 shell 脚本，编写体验也很差。对于这种情况，**可以将复杂的 shell 命令封装在 shell 脚本中，供 Makefile 直接调用，而一些简单的命令则可以直接集成在 Makefile 中。**

**推荐的 Makefile 结构：**

![image-20230219153332640](https://sm.nsddd.top/sm202302191533699.png)



在上面的 Makefile 组织方式中，根目录下的 Makefile 聚合了项目所有的管理功能，这些管理功能通过 Makefile 伪目标的方式实现。同时，还将这些伪目标进行分类，把相同类别的伪目标放在同一个 Makefile 中，这样可以使得 Makefile 更容易维护。对于复杂的命令，则编写成独立的 shell 脚本，并在 Makefile 命令中调用这些 shell 脚本。

举个例子，下面是 IAM 项目的 Makefile 组织结构：

```bash

├── Makefile
├── scripts
│   ├── gendoc.sh
│   ├── make-rules
│   │   ├── gen.mk
│   │   ├── golang.mk
│   │   ├── image.mk
│   │   └── ...
    └── ...
├── Makefile
├── scripts
│   ├── gendoc.sh
│   ├── make-rules
│   │   ├── gen.mk
│   │   ├── golang.mk
│   │   ├── image.mk
│   │   └── ...
    └── ...
```

我们将相同类别的操作统一放在 `scripts/make-rules` 目录下的 Makefile 文件中。**Makefile 的文件名参考分类命名**，例如 `golang.mk`。最后，在 `/Makefile` 中 include 这些 Makefile。

为了跟 Makefile 的层级相匹配，`golang.mk` 中的所有目标都按`go.xxx`这种方式命名。通过这种命名方式，我们可以很容易分辨出某个目标完成什么功能，放在什么文件里，这在复杂的 Makefile 中尤其有用。以下是 IAM 项目根目录下，Makefile 的内容摘录，你可以看一看，作为参考：

```makefile
include scripts/make-rules/golang.mk
include scripts/make-rules/image.mk
include scripts/make-rules/gen.mk
include scripts/make-rules/...

## build: Build source code for host platform.
.PHONY: build
build:
  @$(MAKE) go.build

## build.multiarch: Build source code for multiple platforms. See option PLATFORMS.
.PHONY: build.multiarch
build.multiarch:
  @$(MAKE) go.build.multiarch

## image: Build docker images for host arch.
.PHONY: image
image:
  @$(MAKE) image.build

## push: Build docker images for host arch and push images to registry.
.PHONY: push
push:
  @$(MAKE) image.push

## ca: Generate CA files for all iam components.
.PHONY: ca
ca:
  @$(MAKE) gen.ca
```

另外，一个合理的 Makefile 结构应该具有前瞻性。也就是说，要在不改变现有结构的情况下，接纳后面的新功能。这就需要你整理好 Makefile 当前要实现的功能、即将要实现的功能和未来可能会实现的功能，然后基于这些功能，利用 Makefile 编程技巧，编写可扩展的 Makefile。

这里需要你注意：上面的 Makefile 通过 `.PHONY` 标识定义了大量的伪目标，定义伪目标一定要加 `.PHONY` 标识，否则当有同名的文件时，伪目标可能不会被执行。



## 掌握 Makefile 编写技巧

### 技巧 1：善用通配符和自动变量

Makefile 允许对目标进行类似正则运算的匹配，主要用到的通配符是%。通过使用通配符，可以使不同的目标使用相同的规则，从而使 Makefile 扩展性更强，也更简洁。

我们的 IAM 实战项目中，就大量使用了通配符`%`，例如：`go.build.%`、`ca.gen.%`、`deploy.run.%`、`tools.verify.%`、`tools.install.%`等。

这里，我们来看一个具体的例子，`tools.verify.%`（位于`scripts/make-rules/tools.mk`文件中）定义如下：

```makefile
tools.verify.%:
  @if ! which $* &>/dev/null; then $(MAKE) tools.install.$*; fi
```

`make tools.verify.swagger`, `make tools.verify.mockgen`等均可以使用上面定义的规则，%分别代表了`swagger`和`mockgen`。

如果不使用%，则我们需要分别为tools.verify.swagger和tools.verify.mockgen定义规则，很麻烦，后面修改也困难。

另外，这里也能看出`tools.verify.%`这种命名方式的好处：tools 说明依赖的定义位于`scripts/make-rules/tools.mk` Makefile 中；verify说明`tools.verify.%`伪目标属于 verify 分类，主要用来验证工具是否安装。通过这种命名方式，你可以很容易地知道目标位于哪个 Makefile 文件中，以及想要完成的功能。

另外，上面的定义中还用到了自动变量`$*`，用来指代被匹配的值`swagger`、`mockgen`。



### 技巧 2：善用函数

Makefile 自带的函数能够帮助我们实现很多强大的功能。所以，在我们编写 Makefile 的过程中，如果有功能需求，可以优先使用这些函数。我把常用的函数以及它们实现的功能整理在了 [Makefile](https://github.com/marmotedu/geekbang-go/blob/master/makefile/Makefile%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.md) 常用函数列表 中，你可以参考下。

IAM 的 Makefile 文件中大量使用了上述函数，如果你想查看这些函数的具体使用方法和场景，可以参考 IAM 项目的 Makefile 文件 make-rules。

| 函数名                      | 功能描述                                                     |
| --------------------------- | ------------------------------------------------------------ |
| $(origin )                  | 告诉变量的“出生情况”，有如下返回值： undefined： 从来没有定义过default： 是一个默认的定义environment： 是一个环境变量file： 这个变量被定义在 Makefile中command line： 这个变量是被命令行定义的override： 是被 override 指示符重新定义的automatic： 是一个命令运行中的自动化变量 |
| $(addsuffix ,<names...>)    | 把后缀加到中的每个单词后面，并返回加过后缀的文件名序列。     |
| $(addprefix ,<names...>)    | 把前缀加到中的每个单词前面，并返回加过前缀的文件名序列。     |
| $(wildcard )                | 扩展通配符，例如：(wildcard{ROOT_DIR}/build/docker/*)        |
| $(word ,)                   | 取字符串中第个单词（从一开始），并返回字符串中第个单词。如 比中的单词数要大，那么返回空字符串 |
| $(subst ,,)                 | 把字串 中的 字符串替换成 ，并返回被替换后的字符串            |
| $(eval )                    | 将的内容将作为makefile的一部分而被make解析和执行。           |
| $(firstword )               | 取字符串 中的第一个单词，并返回字符串 的第一个单词           |
| $(lastword )                | 取字符串 中的最后一个单词，并返回字符串 的最后一个单词       |
| $(abspath )                 | 将中的各路径转换成绝对路径，并将转换后的结果返回             |
| $(shell cat foo)            | 执行操作系统命令，并返回操作结果                             |
| $(info <text ...>)          | 输出一段信息                                                 |
| $(warning <text ...>)       | 出一段警告信息，而 make 继续执行                             |
| $(error <text ...>)         | 产生一个致命的错误，<text ...> 是错误信息                    |
| $(filter <pattern...>,)     | 以模式过滤字符串中的单词，保留符合模式的单词。可以有多个模式。返回符合模式的字串 |
| $(filter-out <pattern...>,) | 以模式过滤字符串中的单词，去除符合模式的单词。可以有多个模式，并返回不符合模式的字串 |
| $(dir <names...>)           | 从文件名序列中取出目录部分。目录部分是指最后一个反斜杠（/）之前的部分。返回文件名序列的目录部分。 |
| $(notdir <names...>)        | 从文件名序列中取出非目录部分。非目录部分是指最後一个反斜杠（/）之后的部分。返回文件名序列的非目录部分。 |
| $(strip )                   | 去掉字串中开头和结尾的空字符，并返回去掉空格后的字符串       |
| $(suffix <names...>)        | 从文件名序列中取出各个文件名的后缀。返回文件名序列的后缀序列，如果文件没有后缀，则返回空字串。 |
| $(foreach ,,)               | 把参数中的单词逐一取出放到参数所指定的变量中，然后再执行所包含的表达式。每一次 会返回一个字符串，循环过程中的所返回的每个字符串会以空格分隔，最后当整个循环结束时，所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。 |



### 技巧 3：依赖需要用到的工具

如果 Makefile 某个目标的命令中用到了某个工具，可以将该工具放在目标的依赖中。这样，当执行该目标时，就可以指定检查系统是否安装该工具，如果没有安装则自动安装，从而实现更高程度的自动化。例如，`/Makefile` 文件中，`format` 伪目标，定义如下：

```bash
.PHONY: format
format: tools.verify.golines tools.verify.goimports
  @echo "===========> Formating codes"
  @$(FIND) -type f -name '*.go' | $(XARGS) gofmt -s -w
  @$(FIND) -type f -name '*.go' | $(XARGS) goimports -w -local $(ROOT_PACKAGE)
  @$(FIND) -type f -name '*.go' | $(XARGS) golines -w --max-len=120 --reformat-tags --shorten-comments --ignore-generated .
```

你可以看到，format 依赖`tools.verify.golines tools.verify.goimports`。我们再来看下tools.verify.golines的定义：







## END 链接

<ul><li><div><a href = '6.md' style='float:left'>⬆️上一节🔗  </a><a href = '8.md' style='float: right'>  ️下一节🔗</a></div></li></ul>

+ [Ⓜ️回到目录🏠](../README.md)

+ [**🫵参与贡献💞❤️‍🔥💖**](https://nsddd.top/archives/contributors))

+ ✴️版权声明 &copy; ：本书所有内容遵循[CC-BY-SA 3.0协议（署名-相同方式共享）&copy;](http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0协议文本) 

