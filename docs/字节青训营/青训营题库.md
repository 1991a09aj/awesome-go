# 关于字节青训营的题目





## 第一天训练题

【青训营 - 后端练习题 - DAY1】  
想知道青训营笔试题怎么考？快来这里看看练习题吧！  
编程题 1：[![](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3f843e8626a3844c624fb596dddd9674.svg)code.juejin.cn](https://code.juejin.cn/pen/7180199398167543867 "https://code.juejin.cn/pen/7180199398167543867")  
编程题 2：[![](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3f843e8626a3844c624fb596dddd9674.svg)code.juejin.cn](https://code.juejin.cn/pen/7180200444763832354 "https://code.juejin.cn/pen/7180200444763832354")  
编程题 3：[![](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3f843e8626a3844c624fb596dddd9674.svg)code.juejin.cn](https://code.juejin.cn/pen/7180201853819781157 "https://code.juejin.cn/pen/7180201853819781157")  

选择题 1：  
Client 在使用 Https 协议访问网站进行通信的过程中，以下说法正确的是？  
A. 只用到了对称加密技术  
B. 只用到了非对称加密技术  
C. 没有用到任何加密技术  
D. 同时用到了对称加密和非对称加密技术  

> D. 同时用到了对称加密和非对称加密技术
>
> 在 HTTPS 协议中，客户端 (Client) 和服务端 (Server) 之间的通信过程中，会同时使用对称加密和非对称加密技术。
>
> 对称加密是指使用同一个密钥 (Key) 进行加密和解密的加密方式，常见的对称加密算法包括 AES、DES 等。
>
> 非对称加密是指使用一对密钥 (Key) 进行加密和解密的加密方式，其中一个密钥用于加密，另一个用于解密，常见的非对称加密算法包括 RSA、ECC 等。
>
> 在 HTTPS 协议中，客户端和服务端会通过非对称加密的方式来协商生成一个对称加密的密钥，然后使用这个对称加密的密钥来进行通信。这样做的好处是在协商密钥时可以使用非对称加密的方式来保证通信的安全性，而在通信过程中可以使用对称加密的方式来提高通信的效率。



选择题 2：  
以下哪些是操作系统中堆和栈的区别？  
A. 增长方向  
B. 空间大小  
C. 分配方式  
D. 管理方式

> 在操作系统中，堆 (Heap) 和栈 (Stack) 都是用于存储数据的内存结构，但它们在增长方向、分配方式、管理方式等方面有所不同。
>
> + 增长方向：栈是一种后进先出 (LIFO, Last In First Out) 的数据结构，它的数据元素只能在栈的一端进行插入和删除，具有固定的增长方向。堆则没有固定的增长方向，它的数据元素可以在堆的任何一个位置进行插入和删除。
> + 空间大小：栈和堆都具有有限的存储空间，但是栈的空间通常比堆小，栈的空间是在编译时预先分配的，一般是通过硬件寄存器或者特殊的内存空间来实现的，而堆的空间是在程序运行时动态分配的。
> + 分配方式：栈的内存空间是在编译时就被分配的，无法在运行时进行扩展，而堆的内存空间是在程序运行时动态分配的，可以在运行时通过内存分配函数来进行扩展。
> + 管理方式：栈的内存空间是由操作系统自动管理的，程序员无需关心内存的分配和释放，而堆的内存空间是由程序员自己管理的，程序员需要手动调用内存分配函数来申请内存，并在使用完毕后手动调用内存释放函数来释放内存。
>
> 总结一下，栈和堆的主要区别在于：
>
> + 栈是后进先出的数据结构，堆是无序的数据结构。
> + 栈的内存空间是在编译时预先分配的，堆的内存空间是在程序运行时动态分配的。
> + 栈的内存空间是由操作系统自动管理的，堆的内存空间是由程序员自己管理的。

```
增长方向不同：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方式是向下的，是向着内存地址减小的方向增长。
空间大小不同：在32为系统下面，堆内存可达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定空间大小的，例如，在vc6下面，默认的栈大小好像是1M。当然，也可以自己修改：打开工程。 project-->setting-->link，在category中选中output，然后再reserve中设定堆栈的最大值和 commit。
分配方式不同：堆都是动态分配的；栈有静态和动态两种分配方式。静态分配由编译器完成，比如局部变量的分配。动态分配由 alloca 函数进行、但栈的动态分配和堆是不同的，它的动态分配由编译器进行释放，无需我们手工实现。
管理方式不同：栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏
```




## 第二天训练题

【青训营 - 后端练习题 - DAY2】
想知道青训营笔试题怎么考？快来这里看看练习题吧！
选择题 1：
Go 中关于整型切片的初始化，以下正确的是？
A. s := []int{1, 2, 3, 4, 5}
B. s := make([]int)
C. s := make([]int, 0)
D. s := make([]int, 5, 10)

> 在 Go 中，可以使用以下几种方式初始化整型切片：
> A. s := []int{1, 2, 3, 4, 5}
> 使用花括号初始化切片，可以直接指定切片的元素。这种方式初始化的切片的长度和容量都等于初始化的元素个数。
> C. s := make([]int, 0)
> 使用 make 函数初始化切片，第一个参数为数据类型，第二个参数为切片的长度，第三个参数为切片的容量(可省略)。如果省略第三个参数，容量默认与长度相等。
>
> D. s := make([]int, 5, 10)
> 使用 make 函数初始化切片，并指定切片的长度和容量。这种方式初始化的切片的长度等于第二个参数，容量等于第三个参数。
> B. s := make([]int) 这种方式是错误的，因为 make 函数第二个参数必须指定切片的长度。



选择题 2：
以下哪些操作可能触发本地 CPU cache 失效？
A. 本地读取
B. 本地写入
C. 远端读取
D. 远端写入

> 读取操作不会触发 cache 失效，无论是本地读取还是远端读取。
>
> Cache 失效指的是当 CPU cache 中的某些数据不再有效时，需要更新或清除这些数据。Cache 失效可能会导致性能下降，因为 CPU 在读取数据时会优先从 cache 中获取数据，如果 cache 中的数据无效，则需要去内存或磁盘中读取数据，这需要更多的时间。
>
> 在多处理器系统中，写入操作会触发 cache 失效，因为写入操作可能会更新数据，而其他 CPU 可能会缓存这些数据。如果这些数据被更新了，则其他 CPU 的 cache 中的数据就会变得无效。
>
> 在一些情况下，远端读取操作也可能会触发 cache 失效，但这取决于 CPU 架构和操作系统的实现。在一些情况下，远端读取可能会触发 cache 失效，因为 CPU 可能需要从远端读取数据，然后将这些数据缓存到本地 cache 中。



编程题 1：[![img](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3f843e8626a3844c624fb596dddd9674.svg)code.juejin.cn](https://code.juejin.cn/pen/7180199398167543867)
编程题 2：[![img](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3f843e8626a3844c624fb596dddd9674.svg)code.juejin.cn](https://code.juejin.cn/pen/7180200444763832354)
编程题 3：[![img](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3f843e8626a3844c624fb596dddd9674.svg)code.juejin.cn](https://code.juejin.cn/pen/7180201853819781157)





## 第三天

【青训营 - 后端练习题 - DAY3】
想知道青训营笔试题怎么考？快来这里看看练习题吧！
选择题 1：
以下哪些是解决哈希冲突的手段？
A. 拉链
B. 开放地址
C. 再散列
D. 滑动窗口

> 哈希冲突：不同数经过哈希函数计算后得到同一个结果，即它们会被映射到哈希表的同一个位置。
> 解决哈希冲突，四种方法。
> 开放定址法：遇到冲突时，去寻找新的空闲的哈希地址。
> 再哈希法（再散列）：构造多个哈希函数，冲突时，使用别的哈希函数计算地址。
> 拉链：将所有哈希地址相同的记录都链接在同一个链表中。
> 建立公共溢出区：将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中。

选择题 2：
建立 TLS1.2 连接需要几次握手？
A. 3
B. 4
C. 6
D. 7

> TLS (Transport Layer Security) 协议在建立安全连接时需要进行两次握手。
>
> 首先，客户端发送一个连接请求报文给服务器，该报文包含客户端的协议版本、客户端的随机数、客户端的支持的加密算法等信息。
>
> 然后，服务器收到请求后，会发送一个响应报文给客户端，该报文包含服务器的协议版本、服务器的随机数、服务器的证书、服务器的支持的加密算法等信息。
>
> 最后，客户端收到服务器的响应后，会再次发送一个报文给服务器，该报文包含客户端的随机数和客户端使用的加密算法。
>
> 总共就是两次握手。这两次握手的过程中，客户端和服务器会协商出一组共同使用的加密算法，并使用这组算法在数据传输过程中进行加密和解密。这样就可以保证数据在传输过程中的安全性。

编程题 1：[![img](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3f843e8626a3844c624fb596dddd9674.svg)code.juejin.cn](https://code.juejin.cn/pen/7180199398167543867)
编程题 2：[![img](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3f843e8626a3844c624fb596dddd9674.svg)code.juejin.cn](https://code.juejin.cn/pen/7180200444763832354)
编程题 3：[![img](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/3f843e8626a3844c624fb596dddd9674.svg)code.juejin.cn](https://code.juejin.cn/pen/7180201853819781157)



## 第四天

选择题 1：
MySQL 数据库中是通过以下哪种日志实现 MVCC 机制的？
A. Undo Log
B. Redo Log
C. Binary Log
D. Slow Log



选择题 2：
关于排序算法以下结论正确的是？
A. 归并排序任何情况下都能保持时间复杂度为 O(n*log n)
B. 插入排序时间复杂度为 O(n*n)，所以在任何情况下都比快速排序慢
C. 快速排序的最坏情况下的时间复杂度为 O(n*n)
D. 希尔排序任何情况下都比插入排序更快
